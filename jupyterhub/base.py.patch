diff -cr a/base.py b/base.py
*** a/base.py	Fri Jul 14 14:18:57 2017
--- b/base.py	Fri Jul 14 14:19:15 2017
***************
*** 23,38 ****
  from ..utils import url_path_join
  
  # pattern for the authentication token header
! auth_header_pat = re.compile(r'^(?:token|bearer)\s+([^\s]+)$', flags=re.IGNORECASE)
  
  # mapping of reason: reason_message
  reasons = {
      'timeout': "Failed to reach your server."
!         "  Please try again later."
!         "  Contact admin if the issue persists.",
      'error': "Failed to start your server.  Please contact admin.",
  }
  
  class BaseHandler(RequestHandler):
      """Base Handler class with access to common methods and properties."""
  
--- 23,40 ----
  from ..utils import url_path_join
  
  # pattern for the authentication token header
! auth_header_pat = re.compile(
!     r'^(?:token|bearer)\s+([^\s]+)$', flags=re.IGNORECASE)
  
  # mapping of reason: reason_message
  reasons = {
      'timeout': "Failed to reach your server."
!     "  Please try again later."
!     "  Contact admin if the issue persists.",
      'error': "Failed to start your server.  Please contact admin.",
  }
  
+ 
  class BaseHandler(RequestHandler):
      """Base Handler class with access to common methods and properties."""
  
***************
*** 72,77 ****
--- 74,80 ----
      @property
      def services(self):
          return self.settings.setdefault('services', {})
+ 
      @property
      def hub(self):
          return self.settings['hub']
***************
*** 104,111 ****
      @property
      def csp_report_uri(self):
          return self.settings.get('csp_report_uri',
!             url_path_join(self.hub.base_url, 'security/csp-report')
!         )
  
      @property
      def content_security_policy(self):
--- 107,115 ----
      @property
      def csp_report_uri(self):
          return self.settings.get('csp_report_uri',
!                                  url_path_join(self.hub.base_url,
!                                                'security/csp-report')
!                                  )
  
      @property
      def content_security_policy(self):
***************
*** 126,132 ****
          """
          headers = self.settings.get('headers', {})
          headers.setdefault("X-JupyterHub-Version", __version__)
!         headers.setdefault("Content-Security-Policy", self.content_security_policy)
  
          for header_name, header_content in headers.items():
              self.set_header(header_name, header_content)
--- 130,137 ----
          """
          headers = self.settings.get('headers', {})
          headers.setdefault("X-JupyterHub-Version", __version__)
!         headers.setdefault("Content-Security-Policy",
!                            self.content_security_policy)
  
          for header_name, header_content in headers.items():
              self.set_header(header_name, header_content)
***************
*** 153,159 ****
  
      def get_current_user_oauth_token(self):
          """Get the current user identified by OAuth access token
!         
          Separate from API token because OAuth access tokens
          can only be used for identifying users,
          not using the API.
--- 158,164 ----
  
      def get_current_user_oauth_token(self):
          """Get the current user identified by OAuth access token
! 
          Separate from API token because OAuth access tokens
          can only be used for identifying users,
          not using the API.
***************
*** 166,172 ****
              return None
          else:
              return self._user_from_orm(orm_token.user)
!     
      def get_current_user_token(self):
          """get_current_user from Authorization header token"""
          token = self.get_auth_token()
--- 171,177 ----
              return None
          else:
              return self._user_from_orm(orm_token.user)
! 
      def get_current_user_token(self):
          """get_current_user from Authorization header token"""
          token = self.get_auth_token()
***************
*** 185,190 ****
--- 190,196 ----
              cookie_value,
              max_age_days=self.cookie_max_age_days,
          )
+ 
          def clear():
              self.clear_cookie(cookie_name, path=self.hub.base_url)
  
***************
*** 194,200 ****
                  clear()
              return
          cookie_id = cookie_id.decode('utf8', 'replace')
!         u = self.db.query(orm.User).filter(orm.User.cookie_id==cookie_id).first()
          user = self._user_from_orm(u)
          if user is None:
              self.log.warning("Invalid cookie token")
--- 200,207 ----
                  clear()
              return
          cookie_id = cookie_id.decode('utf8', 'replace')
!         u = self.db.query(orm.User).filter(
!             orm.User.cookie_id == cookie_id).first()
          user = self._user_from_orm(u)
          if user is None:
              self.log.warning("Invalid cookie token")
***************
*** 227,234 ****
          orm_user = orm.User.find(db=self.db, name=name)
          return self._user_from_orm(orm_user)
  
!     def user_from_username(self, username):
          """Get User for username, creating if it doesn't exist"""
          user = self.find_user(username)
          if user is None:
              # not found, create and register user
--- 234,245 ----
          orm_user = orm.User.find(db=self.db, name=name)
          return self._user_from_orm(orm_user)
  
!     def user_from_username(self, nameobj):
          """Get User for username, creating if it doesn't exist"""
+         if type(nameobj) is dict:
+             username = nameobj["name"]
+         else:
+             username = nameobj  # This will explode if it's not a string
          user = self.find_user(username)
          if user is None:
              # not found, create and register user
***************
*** 247,254 ****
          kwargs = {}
          if self.subdomain_host:
              kwargs['domain'] = self.domain
!         self.clear_cookie(self.hub.cookie_name, path=self.hub.base_url, **kwargs)
!         self.clear_cookie('jupyterhub-services', path=url_path_join(self.base_url, 'services'))
  
      def _set_user_cookie(self, user, server):
          # tornado <4.2 have a bug that consider secure==True as soon as
--- 258,267 ----
          kwargs = {}
          if self.subdomain_host:
              kwargs['domain'] = self.domain
!         self.clear_cookie(self.hub.cookie_name,
!                           path=self.hub.base_url, **kwargs)
!         self.clear_cookie('jupyterhub-services',
!                           path=url_path_join(self.base_url, 'services'))
  
      def _set_user_cookie(self, user, server):
          # tornado <4.2 have a bug that consider secure==True as soon as
***************
*** 256,266 ****
          kwargs = {
              'httponly': True,
          }
!         if  self.request.protocol == 'https':
              kwargs['secure'] = True
          if self.subdomain_host:
              kwargs['domain'] = self.domain
!         self.log.debug("Setting cookie for %s: %s, %s", user.name, server.cookie_name, kwargs)
          self.set_secure_cookie(
              server.cookie_name,
              user.cookie_id,
--- 269,280 ----
          kwargs = {
              'httponly': True,
          }
!         if self.request.protocol == 'https':
              kwargs['secure'] = True
          if self.subdomain_host:
              kwargs['domain'] = self.domain
!         self.log.debug("Setting cookie for %s: %s, %s",
!                        user.name, server.cookie_name, kwargs)
          self.set_secure_cookie(
              server.cookie_name,
              user.cookie_id,
***************
*** 297,303 ****
      def authenticate(self, data):
          return gen.maybe_future(self.authenticator.get_authenticated_user(self, data))
  
- 
      #---------------------------------------------------------------
      # spawning-related
      #---------------------------------------------------------------
--- 311,316 ----
***************
*** 333,339 ****
                  # failed, don't add to the proxy
                  return
              toc = IOLoop.current().time()
!             self.log.info("User %s server took %.3f seconds to start", user.name, toc-tic)
              self.statsd.timing('spawner.success', (toc - tic) * 1000)
              yield self.proxy.add_user(user)
              user.spawner.add_poll_callback(self.user_stopped, user)
--- 346,353 ----
                  # failed, don't add to the proxy
                  return
              toc = IOLoop.current().time()
!             self.log.info(
!                 "User %s server took %.3f seconds to start", user.name, toc - tic)
              self.statsd.timing('spawner.success', (toc - tic) * 1000)
              yield self.proxy.add_user(user)
              user.spawner.add_poll_callback(self.user_stopped, user)
***************
*** 347,353 ****
                  # still in Spawner.start, which is taking a long time
                  # we shouldn't poll while spawn is incomplete.
                  self.log.warning("User %s's server is slow to start (timeout=%s)",
!                     user.name, self.slow_spawn_timeout)
                  # schedule finish for when the user finishes spawning
                  IOLoop.current().add_future(f, finish_user_spawn)
              else:
--- 361,367 ----
                  # still in Spawner.start, which is taking a long time
                  # we shouldn't poll while spawn is incomplete.
                  self.log.warning("User %s's server is slow to start (timeout=%s)",
!                                  user.name, self.slow_spawn_timeout)
                  # schedule finish for when the user finishes spawning
                  IOLoop.current().add_future(f, finish_user_spawn)
              else:
***************
*** 358,371 ****
                      # hit timeout, but server's running. Hope that it'll show up soon enough,
                      # though it's possible that it started at the wrong URL
                      self.log.warning("User %s's server is slow to become responsive (timeout=%s)",
!                         user.name, self.slow_spawn_timeout)
!                     self.log.debug("Expecting server for %s at: %s", user.name, user.server.url)
                      # schedule finish for when the user finishes spawning
                      IOLoop.current().add_future(f, finish_user_spawn)
                  else:
                      toc = IOLoop.current().time()
                      self.statsd.timing('spawner.failure', (toc - tic) * 1000)
!                     raise web.HTTPError(500, "Spawner failed to start [status=%s]" % status)
          else:
              yield finish_user_spawn()
  
--- 372,387 ----
                      # hit timeout, but server's running. Hope that it'll show up soon enough,
                      # though it's possible that it started at the wrong URL
                      self.log.warning("User %s's server is slow to become responsive (timeout=%s)",
!                                      user.name, self.slow_spawn_timeout)
!                     self.log.debug("Expecting server for %s at: %s",
!                                    user.name, user.server.url)
                      # schedule finish for when the user finishes spawning
                      IOLoop.current().add_future(f, finish_user_spawn)
                  else:
                      toc = IOLoop.current().time()
                      self.statsd.timing('spawner.failure', (toc - tic) * 1000)
!                     raise web.HTTPError(
!                         500, "Spawner failed to start [status=%s]" % status)
          else:
              yield finish_user_spawn()
  
***************
*** 376,383 ****
          if status is None:
              status = 'unknown'
          self.log.warning("User %s server stopped, with exit code: %s",
!             user.name, status,
!         )
          yield self.proxy.delete_user(user)
          yield user.stop()
  
--- 392,399 ----
          if status is None:
              status = 'unknown'
          self.log.warning("User %s server stopped, with exit code: %s",
!                          user.name, status,
!                          )
          yield self.proxy.delete_user(user)
          yield user.stop()
  
***************
*** 388,393 ****
--- 404,410 ----
          tic = IOLoop.current().time()
          yield self.proxy.delete_user(user)
          f = user.stop()
+ 
          @gen.coroutine
          def finish_stop(f=None):
              """Finish the stop action by noticing that the user is stopped.
***************
*** 399,405 ****
                  # failed, don't do anything
                  return
              toc = IOLoop.current().time()
!             self.log.info("User %s server took %.3f seconds to stop", user.name, toc-tic)
  
          try:
              yield gen.with_timeout(timedelta(seconds=self.slow_stop_timeout), f)
--- 416,423 ----
                  # failed, don't do anything
                  return
              toc = IOLoop.current().time()
!             self.log.info(
!                 "User %s server took %.3f seconds to stop", user.name, toc - tic)
  
          try:
              yield gen.with_timeout(timedelta(seconds=self.slow_stop_timeout), f)
***************
*** 481,486 ****
--- 499,505 ----
  
  class Template404(BaseHandler):
      """Render our 404 template"""
+ 
      def prepare(self):
          raise web.HTTPError(404)
  
***************
*** 490,495 ****
--- 509,515 ----
  
      Redirects /foo to /prefix/foo, etc.
      """
+ 
      def get(self):
          uri = self.request.uri
          if uri.startswith(self.base_url):
***************
*** 535,541 ****
                  if current_user.spawn_pending:
                      # spawn has started, but not finished
                      self.statsd.incr('redirects.user_spawn_pending', 1)
!                     html = self.render_template("spawn_pending.html", user=current_user)
                      self.finish(html)
                      return
  
--- 555,562 ----
                  if current_user.spawn_pending:
                      # spawn has started, but not finished
                      self.statsd.incr('redirects.user_spawn_pending', 1)
!                     html = self.render_template(
!                         "spawn_pending.html", user=current_user)
                      self.finish(html)
                      return
  
***************
*** 573,585 ****
  
  class UserRedirectHandler(BaseHandler):
      """Redirect requests to user servers.
!     
      Allows public linking to "this file on your server".
!     
      /user-redirect/path/to/foo will redirect to /user/:name/path/to/foo
!     
      If the user is not logged in, send to login URL, redirecting back here.
!     
      .. versionadded:: 0.7
      """
      @web.authenticated
--- 594,606 ----
  
  class UserRedirectHandler(BaseHandler):
      """Redirect requests to user servers.
! 
      Allows public linking to "this file on your server".
! 
      /user-redirect/path/to/foo will redirect to /user/:name/path/to/foo
! 
      If the user is not logged in, send to login URL, redirecting back here.
! 
      .. versionadded:: 0.7
      """
      @web.authenticated
